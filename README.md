# StevenHarrington_HashSomethingOut

INDIVIDUAL REFLECTIONS
My first optimization, I tried a division hashing style w/ a linear probing collision method. This consisted of transfering the string to unicode values and then getting the remainder of it divided by the length of the table. The linear probing tried to insert, if there wasn't space, then it moved to the next index. This method was very good because it had no unused spaces, however it had a good amount of collisions and I stopped once the list was full. The collisions was 260254 for movies and 577052 for quotes. The construction was decently quick at .14 for movies and .36 for quotes.

My second optimization, I tried a division hashing style w/ a list appending collision method. This consisted of transfering the string to unicode values and then getting the remainder of it divided by the length of the table. The list appending, tried to insert, if there wasn't space, then it appended to the end of the list at the index. This method was very good because it had 0 unused spaces and it lowered the amount of collisions for both. Each table had 14003 collisions, this is 1/2 the amount for movie and a little over a 1/4 the amount for quotes. The construction speed was the same for movies at .14 seconds, but it was .21 seconds for quotes(.15 seconds faster).

My third optimization, I tried a folding hashing style w/ a list appending collision method. This consisted of transfering the string to unicode values and then add each digit together. Then getting the remainder of it divided by the length of the table. The list appending, tried to insert, if there wasn't space, then it appended to the end of the list at the index. This method was a little worse than the last optimization technique. It had 14969 collisions for movies and 14971 collisions for quotes. Then for unused space, it had 966 for movies and 968 for quotes. I had a table size of 997, which means it only used about 30 spaces. The construction speed was .17 seconds for movies and .21 seconds for quotes.

My fourth optimization, I tried a mid-squared hashing style w/ a list appending collision method. This consisted of transfering the string to unicode values and then squaring the number. Then I took the middle 1/3 of integers. Then getting the remainder of it divided by the length of the table. The list appending, tried to insert, if there wasn't space, then it appended to the end of the list at the index. This was a slight improvement over my previous optimization, It had collisions of 14046 for movies and 14080 for quotes. Then for unused space, we had 43 for movies and 77 for quotes. The construction times consisted of .17 seconds for movies and .21 seconds for quotes. 

My final optimization, I tried a mid squared hashing style w/ a linear probing by prime number collision method. This consisted of transfering the string to unicode values and then squaring the number. Then I took the middle 1/3 of integers. Then getting the remainder of it divided by the length of the table. This collision method worked by attempting to insert at a index, if there was a value there, then it stepped forward by a prime number or 19. If this index didn't exist for the table, then it would expand, so it did. This happened to have the worst results of my optimizations. It had collisions of 5349601 for movies and 4219907 for quotes. For unused space, we had 2345 for movies and 2440 for quotes. To put this in perspective, we had table lengths of 17345 for movies and 17440 for quotes. The construction times were 3.55 seconds for movies and 3.15 seconds for quotes. 

CONCLUSION
As you can see the division hashing style w/ the list appending collision had the best results. While the mid-squared w/ linear probing by prime had the worst results. The division hashing had the best results because it relies on the size of the list, so the spread is a little more even. Also it appends the second, it notices there is something at that spot. This makes it, so we only have 1 collision for each data value, that can't insert regularly. Looking at the rest of the results, we can say with pretty good certainty that the appending collision method is the best of the collisions. This is because the other two were from 2 to even about 357 times more collisions. The mid-squared w/ linear probing by prime did so bad in my opinion because it had to step through and constanly expand the list. This takes up a lot of memory, but it also greatly extends the time needed to set up the table. 
